#pragma config(Sensor, in1,    autoSelector,   sensorPotentiometer)
#pragma config(Sensor, in2,    flipSelector,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  catapultEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl12, catapultSwitch, sensorTouch)
#pragma config(Motor,  port1,           flipMotor,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           intakeMotor,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftCatapultMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           frontLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontRightMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backRightMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightFourBar,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftFourBar,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightCatapultMotor, tmotorVex393_HBridge, openLoop, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  port9,           flipperMotor,    tmotorVex393_MC29, openLoop)
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
bool leftDone = false;
bool rightDone = false;
int distance;
int speed;
//int tickgoal;
bool stayPut;
int catapultConstant = 15;
int catapultEnable = 1;
int catapultFlag = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}
task rightMotor()
{

	//setMotorTarget(frontRightMotor, 3000, 127, false);
	distance = 3000;
	speed = 127;
	stayPut = false;
	rightDone = false;
	setMotorTarget(frontRightMotor, distance, speed, stayPut);
	waitUntil(getMotorEncoder(frontRightMotor)>distance);
	resetMotorEncoder(frontRightMotor);
	rightDone = true;
}

task leftMotor()
{
	leftDone = false;
	distance = 3000;
	speed = 127;
	stayPut = false;
	setMotorTarget(frontLeftMotor, distance, speed, stayPut);
	waitUntil(getMotorEncoder(frontLeftMotor)>distance);
	resetMotorEncoder(frontLeftMotor);
	leftDone = true;
}

task leftMotorTurn()
{
	distance = 3000;
	speed = 127;
	stayPut = false;
	setMotorTarget(frontLeftMotor, distance , speed, stayPut);
	waitUntil(getMotorEncoder(frontLeftMotor)>distance);
	resetMotorEncoder(frontLeftMotor);
}

task rightMotorTurn()
{
	distance = 3000;
	speed = -127;
	stayPut = false;
	setMotorTarget(frontRightMotor, distance, speed,stayPut);
	waitUntil(getMotorEncoder(frontRightMotor)>distance);
	resetMotorEncoder(frontRightMotor);
}

//task leftMotor2();

task leftMotor2()
{
	leftDone = false;
	distance = 3000;
	speed = 127;
	stayPut = false;
	setMotorTarget(frontLeftMotor, distance, speed, stayPut);
	waitUntil(getMotorEncoder(frontLeftMotor)>distance);
	resetMotorEncoder(frontLeftMotor);
	leftDone = true;

}

task rightMotor2()
{
	rightDone = false;
	distance = 3000;
	speed = 127;
	stayPut = false;
	setMotorTarget(frontRightMotor, distance , speed, stayPut);
	waitUntil(getMotorEncoder(frontRightMotor)>distance);
	resetMotorEncoder(frontRightMotor);
	rightDone = true;
}
//int x;

task autoLaunch()
{
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	waitUntil(SensorValue[catapultSwitch] == 1);
	wait1Msec(1350);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
}
/*catapultEnable = 0;
while(!catapultEnable)
{
//moveMotorTarget(rightCatapultMotor, -152, 127, true);
if(x == 0)motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
waitUntil(SensorValue[catapultSwitch] == -80);
motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
x++;
resetMotorEncoder(leftCatapultMotor);
resetMotorEncoder(rightCatapultMotor);
}

else if(x==1)
{
//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
waitUntil(SensorValue[catapultSwitch] == 1);
wait1Msec(200);
waitUntil(SensorValue[catapultSwitch] == 0);
resetMotorEncoder(leftCatapultMotor);
x--;
resetMotorEncoder(leftCatapultMotor);
resetMotorEncoder(rightCatapultMotor);


}

waitUntil(getMotorEncoder(leftCatapultMotor)  > 80);
motor[leftCatapultMotor] = motor[rightCatapultMotor] = catapultConstant;


catapultEnable = 1;
}*/





task Launcher()
{
	/*resetMotorEncoder(leftCatapultMotor);
	resetMotorEncoder(rightCatapultMotor);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	waitUntil(SensorValue[catapultSwitch] == 1);
	resetMotorEncoder(leftCatapultMotor);
	resetMotorEncoder(rightCatapultMotor);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	waitUntil(SensorValue[catapultEncoder] == 135);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
	stopTask(Launcher);*/
	//resetMotorEncoder(leftCatapultMotor);
	//resetMotorEncoder(rightCatapultMotor);
	//resetMotorEncoder(leftCatapultMotor);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	waitUntil(SensorValue[catapultSwitch] == 1);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
	resetMotorEncoder(leftCatapultMotor);
	resetMotorEncoder(rightCatapultMotor);
	wait1Msec(1000);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	//waitUntil(SensorValue[catapultSwitch] == 0);
	//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
	//resetMotorEncoder(leftCatapultMotor);
	//resetMotorEncoder(rightCatapultMotor);
	waitUntil(SensorValue[catapultEncoder] < -100);
	motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
	//resetMotorEncoder(leftCatapultMotor);
	//resetMotorEncoder(rightCatapultMotor);




}


task autonomous()

{
	//1850 is the midpoint of the potentiometer
	/*if(100>SensorValue[autoSelector]> 200)
	{
	motor[frontRightMotor] = 70;
	motor[frontLeftMotor] = 70;
	motor[backRightMotor] = 70;
	motor[backLeftMotor] = 70;
	wait1Msec(3500);
	motor[frontRightMotor] = -70;
	motor[frontLeftMotor] = -70;
	motor[backRightMotor] = -70;
	motor[backLeftMotor] = -70;
	wait1Msec(1500);
	motor[frontRightMotor] = 0;
	motor[frontLeftMotor] = 0;
	motor[backRightMotor] = 0;
	motor[backLeftMotor] = 0;


	}
	if(200>SensorValue[autoSelector] > 300)
	{
	motor[frontRightMotor] = 0;
	motor[frontLeftMotor] = 0;
	motor[backRightMotor] = 0;
	motor[backLeftMotor] = 0;
	}

	if(300>SensorValue[autoSelector] > 400)
	{
	startTask(rightMotor);
	startTask(leftMotor);
	waitUntil(rightDone && leftDone);
	startTask(leftMotor);
	startTask(leftMotorTurn);
	startTask(rightMotorTurn);
	waitUntil(leftMotorTurn && rightMotorTurn);
	startTask(leftMotor2);
	startTask(rightMotor2);
	waitUntil(rightDone && leftDone);
	}*/
	if(SensorValue[autoSelector] > 1850)
	{//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
		//waitUntil(SensorValue[catapultSwitch] == 1);
		//wait1Msec(1100);
		//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
		motor[flipMotor] = 127;
		wait1Msec(250);
		motor[flipMotor] = 0;
		motor[frontLeftMotor] = 127;
		motor[frontRightMotor] = -127;
		motor[backLeftMotor] = 127;
		motor[backRightMotor] = -127;
		wait1Msec(1750);
		motor[frontLeftMotor] = -127;
		motor[frontRightMotor] = 127;
		motor[backLeftMotor] = -127;
		motor[backRightMotor] = 127;
		wait1Msec(1000);
		motor[backLeftMotor] = motor[backRightMotor] = motor[frontLeftMotor] = motor[frontRightMotor] = 0;
	}
	if(SensorValue[autoSelector] < 1850)
	{
		motor[frontRightMotor] = 0;
		motor[frontLeftMotor] = 0;
		motor[backRightMotor] = 0;
		motor[backLeftMotor] = 0;
	}

}

task usercontrol()

{
	int motorFlag = 0;

	while(true)
	{
		//Driving Motor Control
		motor[frontLeftMotor] = vexRT[Ch1] + vexRT[Ch2];
		motor[frontRightMotor] =vexRT[Ch1] - vexRT[Ch2];
		motor[backLeftMotor] = vexRT[Ch1] + vexRT[Ch2];
		motor[backRightMotor] = vexRT[Ch1] - vexRT[Ch2];
		motor[leftFourBar] = vexRT[Ch3];
		motor[rightFourBar] = vexRT[Ch3];
		//motor[armMotor] = vexRT[Ch3];

		//Intake Control
		//if(vexRT[Btn7R] == 1)
		//{
		//motor[intakeMotor] = 127;
		//}
		//else if(vexRT[Btn8D] == 1)
		//{
		//motor[intakeMotor] = -127;
		//}
		//else
		//{
		//motor[intakeMotor] = 0;
		//}


		if(vexRT[Btn7R] == 1)
		{
			if(motorFlag == 0)
			{
				motor[intakeMotor] = 127;
				motorFlag++;
			}
			else if(motorFlag == 1)
			{
				motor[intakeMotor] = 0;
				motorFlag--;
			}


		}

		if(vexRT[Btn7U] == 1)
		{
			if(motorFlag == 0)
			{
				motor[intakeMotor] = -127;
				motorFlag++;
			}
			else if(motorFlag == 1)
			{
				motor[intakeMotor] = 0;
				motorFlag--;
			}
		}
		if(vexRT[Btn8L] == 1)
		{

			startTask(autoLaunch);
			//startTask(Launcher);


		}



		if(vexRT[Btn5U] == 1)
		{
			motor[flipMotor] = -127;
		}
		//while(vexRT[Btn5U] == 0)
		//{
		//motor[flipMotor] = 0;
		//}
		else if(vexRT[Btn5D] == 1)
		{
			motor[flipMotor] = 127;
		}
		else//(vexRT[Btn5U] + vexRT[Btn5D] == 0)
		{
			motor[flipMotor] = 0;
		}


		if(vexRT[Btn6D] == 1)
		{
			while(SensorValue[flipSelector] < 1390)
			{
				motor[flipMotor] = 127;
			}
			while(SensorValue[flipSelector] > 1390)
			{
				motor[flipMotor] = 0;
			}
		}
		if(vexRT[Btn6U] == 1)
		{
			while(SensorValue[flipSelector] > 1)
			{
				motor[flipMotor] = -127;
			}
			while(SensorValue[flipSelector] < 1)
			{
				motor[flipMotor] = 0;
			}
		}
		//while(vexRT[Btn5D] == 0)
		//{
		//motor[flipMotor] = 0;
		//}
		//else
		//{
		//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
		//}

		/*if(vexRT[Btn6U] == 1)
		{
			if(SensorValue[autoSelector] > 1850)
			{//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 127;
				//waitUntil(SensorValue[catapultSwitch] == 1);
				//wait1Msec(1100);
				//motor[leftCatapultMotor] = motor[rightCatapultMotor] = 0;
				motor[flipMotor] = 127;
				wait1Msec(250);
				motor[flipMotor] = 0;
				motor[frontLeftMotor] = 127;
				motor[frontRightMotor] = -127;
				motor[backLeftMotor] = 127;
				motor[backRightMotor] = -127;
				wait1Msec(1500);
				motor[frontLeftMotor] = -127;
				motor[frontRightMotor] = 127;
				motor[backLeftMotor] = -127;
				motor[backRightMotor] = 127;
				wait1Msec(1000);
				motor[backLeftMotor] = motor[backRightMotor] = motor[frontLeftMotor] = motor[frontRightMotor] = 0;
			}
			if(SensorValue[autoSelector] < 1850)
			{
				motor[frontRightMotor] = 0;
				motor[frontLeftMotor] = 0;
				motor[backRightMotor] = 0;
				motor[backLeftMotor] = 0;
			}

		}*/
	}
}






//if(x == 1)
//{
//motor[intakeMotor] = 0;
//x --;
//}
//else if(vexRT[Btn8D] == 1)
//{
//motor[intakeMotor] = 0;
//}

//else
//{
//motor[intakeMotor] = 0;
//}
